<html>
  <head>
    <title>This is the title</title>
    <style>
      body {
        color: purple;
        background-color: #ffeedd;
      }
      .revealer-container {
        width:100%;
        height:100%;
        position:relative; /* needed to make children position:absolute work properly */

        user-select:none; /* seems to be adequate to prevent select on all descendents. without this, the two images get haphazardly selected during dragging. :-( not sure whether it will be appropriate for maps though */
      }
      .revealer-container img {
        /* this should maybe actually be policy, for the revealed children? */
        width:100%;
        height:100%;
        position:absolute;

        /* without the following, once in a while attempts to move the handle are half-interpreted as img ghost drags in which the handle gets the mousedown but there's no mouseup-- frustrating */
        user-drag:none;
        -webkit-user-drag: none; /* this is the one that's honored, in chrome 55.0.2883.44 beta anyway */
        -khtml-user-drag: none;
        -moz-user-drag: none;
        -o-user-drag: none;
      }

      /* actually should try to do this solely with pseudo-elements? and/or the enable function could add the element if not already there.  hmm I think the latter; pseudo-elements are not that configurable (can only be a before and an after) */
      .revealer-handle {

        /* the primary one is the full-height one, so we can use a percantage of the parent */
        width:1px;
        height:100%;

        /* background-color:rgba(127,127,127, .5); */
        background-color:black;
        position:absolute;
        left:50%; top:50%; transform:translate(-50%,-50%); /* thanks https://css-tricks.com/centering-css-complete-guide/#vertical-block  http://zerosixthree.se/vertical-align-anything-with-just-3-lines-of-css/ */
        cursor: ew-resize;
      }
      /* note, for some reason the "before" pseudo-element (or pseudo-class) comes out stacked on top of the primary thing (but under the "after" pseudo-element if any). is this a bug? */
      .revealer-handle:before { /* thick invisible line for easier selection */
        width:16px;
        height:100%;
        position:absolute;
        left:50%; top:50%; transform:translate(-50%,-50%); /* thanks https://css-tricks.com/centering-css-complete-guide/#vertical-block  http://zerosixthree.se/vertical-align-anything-with-just-3-lines-of-css/ */
        background-color:transparent;
        content:''; /* pseudo-elements require content to function  */
      }
      .revealer-handle:after {
        width:8px;
        height:20px;

        position:absolute;
        left:50%; top:50%; transform:translate(-50%,-50%); /* thanks https://css-tricks.com/centering-css-complete-guide/#vertical-block  http://zerosixthree.se/vertical-align-anything-with-just-3-lines-of-css/ */
        background-color: #00c000; /* slightly darkened green */
        background-color: #a080ff;
        content:''; /* pseudo-elements require content to function  */
      }
    </style>
  </head>
  <body>
    <br>
    Original before and after images:
    <img src="http://egegorgulu.com/assets/img/beforeafter/before.jpg" width="200" height="100">
    <img src="http://egegorgulu.com/assets/img/beforeafter/after.jpg" width="200" height="100">       
    <hr>
    Revealers:
    <br>

    <!-- Rationales:
        - position is needed on container to make children position:absolute work properly
        - user-select:none needed to prevent selecting images by mistake. putting this on the container seems to be adequate.  (jotform's doesn't bother)
        - draggable="false" (or -webkit-user-drag:none in chrome) prevents img ghost dragging, which interacts badly with what I'm doing.
          Still problems:
            - I get a mouse down without mouse up when right-click (if i don't disable right-click menus)
            - I get a mouse down without mouse up sometimes when it decides to initiate dragging on the img
              (if I don't set draggable="false" on the image)

    -->
    <table style="width:100%; height:50%;">
      <tr>
        <td>
          <div id="container1" class="revealer-container"> <!-- position is needed to make children position:absolute work properly -->
            <img class="revealer-child-W" src="http://egegorgulu.com/assets/img/beforeafter/before.jpg" style="clip-path: inset(0 50% 0 0)">
            <img class="revealer-child-E" src="http://egegorgulu.com/assets/img/beforeafter/after.jpg" style="clip-path: inset(0 0 0 50%);">
            <div class="revealer-handle"></div>
          </div>
        </td>
        <td>
          <div id="container1" class="revealer-container"> <!-- position is needed to make children position:absolute work properly -->
            <img class="revealer-child-W" src="http://egegorgulu.com/assets/img/beforeafter/before.jpg" style="clip-path: inset(0 50% 0 0)">
            <img class="revealer-child-E" src="http://egegorgulu.com/assets/img/beforeafter/after.jpg" style="clip-path: inset(0 0 0 50%);">
            <div class="revealer-handle"></div>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <div id="container1" class="revealer-container"> <!-- position is needed to make children position:absolute work properly -->
            <img class="revealer-child-W" src="http://egegorgulu.com/assets/img/beforeafter/before.jpg" style="clip-path: inset(0 50% 0 0)">
            <img class="revealer-child-E" src="http://egegorgulu.com/assets/img/beforeafter/after.jpg" style="clip-path: inset(0 0 0 50%);">
            <div class="revealer-handle"></div>
          </div>
        </td>
        <td>
          <div id="container1" class="revealer-container"> <!-- position is needed to make children position:absolute work properly -->
            <img class="revealer-child-W" src="http://egegorgulu.com/assets/img/beforeafter/before.jpg" style="clip-path: inset(0 50% 0 0)">
            <img class="revealer-child-E" src="http://egegorgulu.com/assets/img/beforeafter/after.jpg" style="clip-path: inset(0 0 0 50%);">
            <div class="revealer-handle"></div>
          </div>
        </td>
      </tr>
    </table>
  </body>
  <script>
    "use strict";
    let setUpRevealer = function(container) {
      let verboseLevel = 1;
      if (verboseLevel >= 1) console.log("    in setupRevealer(container=",container,")");
      let handles = container.getElementsByClassName("revealer-handle");
      if (handles.length != 1) {
        throw new Error("setUpRevealer: number of elements of class \"revealer-handle\" under container is "+handles.length+", expected 1");
      }
      if (verboseLevel >= 1) console.log("      handles=",handles);
      let handle = handles[0];

      // XXX TODO: handle and sanity check all cases:
      //        W E
      //        N S
      //        NW NE S
      //        SE SW N
      //        NW SW E
      //        NE SE W
      //        NW NE SW SE
      let childN = container.getElementsByClassName("revealer-child-N")[0];
      let childS = container.getElementsByClassName("revealer-child-S")[0];
      let childW = container.getElementsByClassName("revealer-child-W")[0];
      let childE = container.getElementsByClassName("revealer-child-E")[0];
      let childNW = container.getElementsByClassName("revealer-child-NW")[0];
      let childSW = container.getElementsByClassName("revealer-child-SW")[0];
      let childNE = container.getElementsByClassName("revealer-child-NE")[0];
      let childSE = container.getElementsByClassName("revealer-child-SE")[0];

      handle.addEventListener("mousedown", event => {
        let verboseLevel = 0;
        if (verboseLevel >= 1) console.log("        in mousedown(event=",event,")");
        if (verboseLevel >= 1) console.log("          event=",event);
        // there are a bunch of X,Y's, apparently clientX,clientY are the only portable reliable ones.
        let x_on_mousedown = event.clientX;
        let y_on_mousedown = event.clientY;
        let x = x_on_mousedown;
        let y = y_on_mousedown;
        let handle_left_on_mousedown = getComputedStyle(handle, null).left; // in pixels unfortunately
        if (verboseLevel >= 1) console.log("          handle_left_on_mousedown = ",handle_left_on_mousedown);
        if (!handle_left_on_mousedown.endsWith('px')) {
          throw new Error("Expected style to end in 'px', got "+JSON.stringify(handle_left_on_mousedown));
        }
        let handle_left_pixels_on_mousedown = parseFloat(handle_left_on_mousedown); /* trailing 'px' ignored per doc */
        if (verboseLevel >= 1) console.log("          handle_left_pixels_on_mousedown = ",handle_left_pixels_on_mousedown);
        // TODO: look into possibly using getBoundingClientRect() or getClientRects()
        let container_width_on_mousedown = container.offsetWidth;
        if (verboseLevel >= 1) console.log("          container_width_on_mousedown = ",container_width_on_mousedown);
        let handle_left_percentage_on_mousedown = handle_left_pixels_on_mousedown / container_width_on_mousedown * 100;
        if (verboseLevel >= 1) console.log("          handle_left_percentage_on_mousedown = ",handle_left_percentage_on_mousedown);
        // Add mousemove and mouseup handlers to document,
        // not to handle element
        // (or even to to handle's ancestors, which is what jotform's does).
        // That makes sure we see the events even if outside the element
        // (even if outside the window).
        // In particular, we'll see the mouseup even if it's outside the element
        // (even outside the window), thereboy avoiding a common type of bug
        // in which we get into a state where we think the mouse is down when it isn't.
        // removeEventListener requires named functions, not anonymous...
        let mousemove = function(event) {
          let verboseLevel = 0;
          if (verboseLevel >= 2) console.log("            in mousemove");

          //console.log("              event=",event);
          let Dx = event.clientX - x_on_mousedown;
          let Dy = event.clientY - y_on_mousedown;
          let dx = event.clientX - x;
          let dy = event.clientY - y;
          x = event.clientX;
          y = event.clientY;
          if (verboseLevel >= 1) console.log("              button = ",event.button);
          if (verboseLevel >= 1) console.log("              buttons = ",event.buttons);
          if (verboseLevel >= 1) console.log("              dx,y = "+dx+","+dy+"  Dx,y = "+Dx+","+Dy+"  x,y="+x+","+y);

          // Make sure a button is still down.
          // If not, abort the manipulation.
          // This prevents various screwups in which the mouseup gets lost
          // (e.g. bringing up menu, initiating drag on images, ...)
          if (event.buttons === 0) {
            console.log("              HEY! mouse button not down any more!  aborting manipulation");
            document.removeEventListener("mousemove", mousemove);
            document.removeEventListener("mouseup", mouseup);
            return;
          }


          if (dx != 0) {
            // Compute new percentage.
            let new_left_pixels = handle_left_pixels_on_mousedown + Dx;
            if (verboseLevel >= 1) console.log("                  new_left_pixels = "+new_left_pixels);
            let new_left_percentage = new_left_pixels / container_width_on_mousedown * 100;
            if (verboseLevel >= 1) console.log("                  new_left_percentage = "+new_left_percentage);
            // Clamp new percentage to [0,100].
            let clamp = (x,a,b) => x<=a?a:x>=b?b:x;
            new_left_percentage = clamp(new_left_percentage, 0, 100);
            if (verboseLevel >= 1) console.log("                  new_left_percentage = "+new_left_percentage+" (clamped)");


            // Set the following to it, in percentage rather than pixels
            // (for graceful behavior on resize):
            //   - handle's left
            //   - child-W's clip inset right
            //   - child-E's clip inset left
            // etc.
            let freeNS = !(childE !== undefined && childW !== undefined); // it's only non-free in that one configuration
            let freeEW = !(childN !== undefined && childN !== undefined); // it's only non-free in that one configuration
            if (freeEW) handle.style.left = new_left_percentage+'%';
            if (freeNS) handle.style.top = new_top_percentage+'%';

            if (childN !== undefined) childN.style.clipPath = "inset(0 0 "+(100-new_top_percentage)+"% 0)";
            if (childE !== undefined) childE.style.clipPath = "inset(0 0 0 "+new_left_percentage+"%)";
            if (childS !== undefined) childS.style.clipPath = "inset("+new_top_percentage+"%) 0 0 0)";
            if (childW !== undefined) childW.style.clipPath = "inset(0 "+(100-new_left_percentage)+"% 0 0)";
            if (childNW !== undefined) childNW.style.clipPath = "inset(0 "+(100-new_left_percentage)+"% "+(100-new_top_percentage)+"% 0)";
            if (childSE !== undefined) childSE.style.clipPath = "inset("+new_top_percentage+"%) 0 0 "+new_left_percentage+"%)";
            if (childSW !== undefined) childSW.style.clipPath = "inset("+new_top_percentage+"%) "+(100-new_left_percentage)+"% 0 0)";
            if (childNE !== undefined) childNE.style.clipPath = "inset(0 0 "+(100-new_top_percentage)+"% "+new_left_percentage+"%)";
          }

          if (verboseLevel >= 2) console.log("            out mousemove");
        };
        let mouseup = function(event) {
          if (verboseLevel >= 1) console.log("        in mouseup(event=",event,")");
          document.removeEventListener("mousemove", mousemove);
          document.removeEventListener("mouseup", mouseup);
          if (verboseLevel >= 1) console.log("        out mouseup(event=",event,")");
        };
        document.addEventListener("mousemove", mousemove);
        document.addEventListener("mouseup", mouseup);
        if (verboseLevel >= 1) console.log("        out mousedown(event=",event,")");
      });
      if (verboseLevel >= 1) console.log("    out setupRevealer(container=",container,")");
    };
    var containers = document.getElementsByClassName("revealer-container");
    console.log("  containers=",containers);
    for (let container of containers) {
      setUpRevealer(container);
    }
  </script>
</html>
